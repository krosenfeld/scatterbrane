
"""
.. module:: utilities
    :platform: Unix
    :synopsis: Helpful function for ScatterBrane

.. moduleauthor:: Katherine Rosenfeld <krosenf@gmail.com>
.. moduleauthor:: Michael Johnson

"""
from __future__ import print_function

import numpy as np
from scipy.interpolate import RectBivariateSpline
from scipy.ndimage.filters import gaussian_filter
from astropy.io import fits

def smoothImage(img,dx,fwhm):
    '''
    Returns Image smoothed by a gaussian kernel.

    :param img: ``(n, n)`` 
      numpy array
    :param dx: scalar 
      Pixel scale in microarcseconds
    :param fwhm: scalar
      Gaussian full width at half maximum in microarcseconds
    '''
    return gaussian_filter(img,fwhm/(2*np.sqrt(np.log(4)))/dx)

def getCoherenceLength(theta,wavelength=1.3e-3,magnification=0.448):
    '''
    :param theta: scalar
        FWHM of scattering kernel at 1 cm in milli-arcseconds.
    :param wavelength: (optional) scalar
        Observing wavelength in meters
    :param magnification: (optional) scalar
        Magnification factor (scatterer-observer)/(source-scatterer).

    :returns: scalar
        Coherence length in km.
    '''
    #return (wavelength*1e-3)*np.sqrt(np.log(4))/(np.pi*np.sqrt(1+magnification)**2*np.radians(1e-3/3600*theta*(wavelength*1e2)**2))
    return (wavelength*1e-3)*np.sqrt(np.log(4))/(np.pi*(1+magnification)*np.radians(1e-3/3600*theta*(wavelength*1e2)**2))

def ensembleSmooth(img,dx,brane,return_kernel=False):
    '''
    Generates ensemble averaged image given scattering kernel parameters.

    :param img: ``(n, n)`` 
      numpy array
    :param dx: scalar
      Pixel scale in microarcseconds
    :param brane: Brane object.
    :param return_kernel: (optional) bool 
      Return tuple with uv kernel (:func:`nump.fft.rfft2` format). See :func:`getUVKernel` for an alternate method. 
    '''
    nx = img.shape[0]

    # scattering kernel parameters in wavelengths 
    sigma_maj = brane.wavelength*np.sqrt(np.log(4)) / (np.pi*(1.+brane.m)*brane.r0) / (2*np.sqrt(np.log(4)))
    sigma_min = sigma_maj / brane.anisotropy
    v = np.dot(np.transpose([np.fft.fftfreq(nx,d=dx*np.radians(1.)/(3600*1e6))]),[np.ones(nx/2 + 1)])
    u = np.dot(np.transpose([np.ones(nx)]),[np.fft.rfftfreq(nx,d=dx*np.radians(1.)/(3600*1e6))])

    # rotate
    if brane.pa != None:
        theta = np.radians(90-brane.pa)
    else:
        theta = np.radians(0.)
    u_ = np.cos(theta)*u - np.sin(theta)*v
    v = np.sin(theta)*u + np.cos(theta)*v

    # rotate
    G = np.exp(-2*np.pi**2*(u_**2*sigma_maj**2 + v**2*sigma_min**2))
    V = np.fft.rfft2(img)

    if return_kernel:
        return (np.fft.irfft2(V*G,s=img.shape),G)
    else:
        return np.fft.irfft2(V*G,s=img.shape)

def getUVKernel(u,v,brane):
    '''
    Get ensemble kernel in visibility plane for specified uv points.  See func:`ensembleSmooth` for an althernate method.

    :param u: ``(n, )`` 
      Samples of u in units of wavelengths.
    :param v: ``(n, )`` 
      Samples of v in units of wavelengths. 
    :param brane: Brane object 

    :returns: ``(n, )`` Ensemble kernel complex visibility
    '''
    # scattering kernel parameters in wavelengths 
    sigma_maj = brane.wavelength*np.sqrt(np.log(4)) / (np.pi*(1.+brane.m)*brane.r0) / (2*np.sqrt(np.log(4)))
    sigma_min = sigma_maj / brane.anisotropy

    # rotate
    if brane.pa != None:
        theta = np.radians(90-brane.pa)
    else:
        theta = np.radians(0.)

    u_ = np.cos(theta)*u - np.sin(theta)*v
    v_ = np.sin(theta)*u + np.cos(theta)*v

    # rotate and return
    return np.exp(-2*np.pi**2*(u_**2*sigma_maj**2 + v_**2*sigma_min**2))


def loadSettings(filename):
  '''
    Loads simulation settings from a file generated by :func:`Brane.save_settings`.

   :param filename: string 
     File name that contains simulation settings.

   :returns: A dictionary with simulation settings.

  '''
  return dict(np.genfromtxt(filename,\
                dtype=[('a','|S10'),('f','float')],delimiter='\t',autostrip=True))

def regrid(a,inx,idx,onx,odx):
  '''
    Regrids array with a new resolution and pixel number.

    :param a: ``(n, n)`` 
      Input numpy image
    :param inx: int
      Number of input pixels on a side
    :param idx: scalar
      Input resolution element 
    :param onx: int 
      Number of output pixels on a side
    :param odx: scalar
      Output resolution element 

    :returns: Array regridded to the new resolution and field of view. 
  '''
  x = idx * (np.arange(inx) - 0.5 * (inx - 1))
  f = RectBivariateSpline(x,x,a)
  x_ = odx * (np.arange(onx) - 0.5 * (onx - 1))
  xx_,yy_ = np.meshgrid(x_,x_,indexing='xy')
  m = f.ev(yy_.flatten(),xx_.flatten()).reshape((onx,onx))
  return m*(odx/idx)**2

def writefits(m,dx,dest='image.fits',obsra=266.4168370833333,obsdec=-29.00781055555555,freq=230e9):
    '''
    Write fits file with header.  Defaults are set for Sgr A* at 1.3mm.

    :param m: ``(n, n)``
      numpy image array
    :param dx: scalar 
      Pixel size in microarcseconds
    :param dest: (optional) string 
      Output fits file name
    :param obsra: (optional) scalar 
      Source right ascension 
    :param obsdec: (optional) scalar 
      Source declination
    '''
    hdu = fits.PrimaryHDU(m)
    hdu.header['CDELT1'] = -1*dx*np.radians(1.)/(3600.*1e6)
    hdu.header['CDELT2'] = dx*np.radians(1.)/(3600.*1e6)
    hdu.header['OBSRA']  = obsra
    hdu.header['OBSDEC'] = obsdec
    hdu.header['FREQ'] = freq
    hdu.writeto(dest,clobber=True)

def FTElementFast(img,dx,baseline):
    '''
    Return complex visibility.

    :param img: ``(n, n)`` 
      numpy image array 
    :param dx: scalar 
      Pixel size in microarcseconds
    :param baseline: ``(2, )``
      (u,v) point in wavelengths

    .. note:: To shift center try multipliny by :math:`\\mathrm{exp}(\\pi i u n_x\\Delta_x)` and watch out for the axis orientation.
    '''
    nx = img.shape[-1]
    du = 1./(nx * dx * np.radians(1.)/(3600*1e6)) 
    ind = np.arange(nx)
    return np.sum(img * np.dot(\
             np.transpose([np.exp(-2j*np.pi/du/nx*baseline[1]*np.flipud(ind))]),\
             [np.exp(-2j*np.pi/du/nx*baseline[0]*ind)]))
